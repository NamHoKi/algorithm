# 순위 검색

[프로그래머스 > 2021 카카오 블라인드 > 순위 검색](https://programmers.co.kr/learn/courses/30/lessons/72412)



## 문제

너무 길어서 생략



## 풀이

### First Try 

- 정확성은 100점이나, 효율성 0점인 풀이

  <img width="300" alt="스크린샷 2021-09-16 오후 12 27 19" src="https://user-images.githubusercontent.com/72188416/133544640-77a95058-2adc-4cf3-8ded-3b7c11d63615.png">

```swift
func solution(_ info:[String], _ query:[String]) -> [Int] {
    let infos = info.map{ $0.components(separatedBy: " ") }
    var results = [Int]()
    
    query.forEach { queryString in
        let queries = queryString.components(separatedBy: " ").filter { $0 != "and" }
        let queryResult = infos.filter { isRightPerson(info: $0, query: queries) }.count
        results.append(queryResult)
    }
    return results
}

func isRightPerson(info: [String], query: [String]) -> Bool {
    for i in 0...3 {
        if !isSame(info[i], query[i]) {
            return false
        }
    }
    return isBigger(info[4], query[4])
}

func isSame(_ value: String,_ condition: String) -> Bool {
    if condition == "-" {
        return true
    } else {
        return value == condition
    }
}

func isBigger(_ scoreString: String,_ cutlineString: String) -> Bool {
    let score = Int(scoreString)!
    let cutline = Int(cutlineString)!
    return score >= cutline
}
```







### Second Try

- 효율성을 높일 수 있는 방법에 대한 생각

  - 앞선 필터에서 걸러진 참가자들에 대해서만 다음 필터를 적용한다
  - 제약 조건이 없는 (- 인) 경우에는 필터를 하지 않고 전부 넘긴다 

- 하지만 여전히 효율성은 0점.....별반 나아지지 않음.

  <img width="300" alt="스크린샷 2021-09-16 오후 12 26 25" src="https://user-images.githubusercontent.com/72188416/133544566-7f355333-745d-40c7-a554-256028f4315c.png">

```swift
func solution(_ info:[String], _ query:[String]) -> [Int] {
    let infos = info.map{ $0.components(separatedBy: " ") }
    var results = [Int]()
    
    query.forEach { queryString in
        let queries = queryString.components(separatedBy: " ").filter { $0 != "and" }
        let queryResult = rightPeopleCount(from: infos, conditions: queries)
        results.append(queryResult)
    }
    return results
}

func rightPeopleCount(from infos: [[String]], conditions: [String]) -> Int {
    var filteredInfo = infos
    
    for i in 0..<conditions.count {
        if conditions[i] == "-" { continue }
        
        if i == conditions.count - 1 {
            filteredInfo = filteredInfo.filter { isBigger($0[i], conditions[i])}
        } else {
            filteredInfo = filteredInfo.filter { $0[i] == conditions[i] }
        }
    }
    return filteredInfo.count
}

func isBigger(_ scoreString: String,_ cutlineString: String) -> Bool {
    let score = Int(scoreString)!
    let cutline = Int(cutlineString)!
    return score >= cutline
}
```





### Third Try

- Query를 하나씩 처리하지 말고, 모든 Query를 병렬적으로 검사한다면? -> 그래도 O(n2)이어야 하는건 변함이 없음
- 앞선 쿼리 결과를 저장해놓으면 어떨까? 그 다음 쿼리부터는 바로 결과를 빼오면 됨
- 총 24가지 경우의 수가 나올 것..이 아니라 전부 가능한 경우도 쳐야돼서 108가지 -> 과연 효율적인 걸까..? -> 쿼리가 최대 100000건. 데이터가 많아질수록 효율성 올라갈 것.
- 이후, 점수 필터링만 거쳐서 결과 도출

- ㅠㅠ 여전히 효율성 0... 테스트케이스에서는 데이터가 많을 시 확연히 시간이 줄어들긴 했음

  <img width="300" alt="스크린샷 2021-09-16 오후 1 43 57" src="https://user-images.githubusercontent.com/72188416/133550805-55d0742b-cd21-48bf-8815-92fe3a793ad8.png">

```swift
func solution(_ info:[String], _ query:[String]) -> [Int] {
    let allInfos = info.map{ $0.components(separatedBy: " ") }
    let allConditions = [["cpp", "java", "python"], ["backend", "frontend"], ["junior", "senior"], ["chicken", "pizza"]]
    let queriedInfo = allQueriedInfo(from: allInfos, allConditions: allConditions)
    
    let queries = query.map { $0.components(separatedBy: " ").filter { $0 != "and" } }
    var results = [Int]()
    
    queries.forEach { query in
        let key = createQueryKey(from: query)
        let currentFilteredInfo = queriedInfo[key] ?? allInfos
        let scoreFilteredInfo = currentFilteredInfo.filter { isBigger($0[4], query[4]) }
        results.append(scoreFilteredInfo.count)
    }
    return results
}

func allQueriedInfo(from allInfos: [[String]], allConditions: [[String]]) -> [String: [[String]]] {
    let allQuery = allConditions.map { $0 + ["-"] }
    var queriedInfo = [String: [[String]]]()
    
    func createQueriedInfo(queryLevel: Int, queryString: String, filteredInfo: [[String]]) {
        if queryLevel < allQuery.count {
            let currentQuery = allQuery[queryLevel]
            
            currentQuery.forEach { condition in
                let newFilteredInfo = filteredInfo.filter { isSame($0[queryLevel], condition) }
                let newQueryString = queryString + condition
                createQueriedInfo(queryLevel: queryLevel + 1, queryString: newQueryString, filteredInfo: newFilteredInfo)
            }
        } else {
            queriedInfo[queryString] = filteredInfo
        }
    }
    createQueriedInfo(queryLevel: 0, queryString: "", filteredInfo: allInfos)
    return queriedInfo
}

func createQueryKey(from conditions: [String]) -> String {
    var currentKey = ""
    
    for i in 0...3 {
        currentKey += conditions[i]
    }
    return currentKey
}

func isBigger(_ scoreString: String,_ cutlineString: String) -> Bool {
    let score = Int(scoreString)!
    let cutline = Int(cutlineString)!
    return score >= cutline
}

func isSame(_ info: String, _ condition: String) -> Bool {
    if condition == "-" {
        return true
    } else {
        return info == condition
    }
}
```





### Forth Try

- 새로운 알고리즘을 도입해야 하는 걸까?
- 공부가 부족하다고 판단하여 우선 카카오의 풀이를 들춰 봄

- 효율성 4.49%만이 통과하였군..

<img width="705" alt="스크린샷 2021-09-16 오후 1 46 29" src="https://user-images.githubusercontent.com/72188416/133551029-7b6c6de9-a3c5-4f9f-aeee-b3984ed053e1.png">

- `지원자들을 그룹별로 적절하게 미리 분류해두면 매 문의 조건마다 지원자들을 INFO 배열에서 찾지 않아도 됩니다`

  일단 3번의 접근 방향은 괜찮았던 것 같은데 여기서 한발 더 나가야 했다

  > 숫자가 오름차순으로 정렬된 배열에서 X라는 숫자를 찾는 효율적인 방법으로 binary search를 사용할 수 있습니다. 이때, 배열에 X가 없을 수도 있으므로, 배열에서 X보다 크거나 같은 숫자가 처음 나타나는 위치를 찾아야 하며, 이는 lower bound를 이용하면 됩니다

  사실 이것도 생각을 못했던 건 아닌데 특정 점수가 없는 경우라면 찾을 수 있을까? 생각해서 사용하지 않았던 방법...

  이걸 구현해봤다면 가능하다고 생각했겠지? 그러니까 지금 구현해봐야겠다....

  

```swift
func solution(_ info:[String], _ query:[String]) -> [Int] {
    let allInfos = info.map{ $0.components(separatedBy: " ") }.sorted { Int($0[4])! < Int($1[4])! }
    let allConditions = [["cpp", "java", "python"], ["backend", "frontend"], ["junior", "senior"], ["chicken", "pizza"]]
    let queriedInfo = allQueriedInfo(from: allInfos, allConditions: allConditions)
    
    let queries = query.map { $0.components(separatedBy: " ").filter { $0 != "and" } }
    var results = [Int]()
    
    queries.forEach { query in
        let key = createQueryKey(from: query)
        let currentFilteredInfo = queriedInfo[key] ?? allInfos
        let scoreFilteredCount = createScoreFilteredCount(targetScoreString: query[4], infos: currentFilteredInfo)
        results.append(scoreFilteredCount)
    }
    return results
}

func createQueryKey(from conditions: [String]) -> String {
    var currentKey = ""
    
    for i in 0...3 {
        currentKey += conditions[i]
    }
    return currentKey
}

func createScoreFilteredCount(targetScoreString: String, infos: [[String]]) -> Int {
    let targetScore = Int(targetScoreString)!
    let totalCount = infos.count
    var start = 0
    var end = totalCount - 1
    var pointer = (start + end) / 2
    var currentScore = -1
    
    while start <= end {
        pointer = (start + end) / 2
        currentScore = Int(infos[pointer][4])!
        
        if currentScore == targetScore {
            let realTargetIndex = createRealTargetIndex(startAt: pointer, targetScore: targetScore, infos: infos)
            return totalCount - realTargetIndex
        } else if currentScore < targetScore {
            start = pointer + 1
        } else if currentScore > targetScore {
            end = pointer - 1
        }
    }
    
    if currentScore < targetScore && (infos.count <= pointer + 1 || Int(infos[pointer+1][4])! > targetScore) {
        let valueToSubtract = min(pointer + 1, totalCount)
        return totalCount - valueToSubtract
    } else if currentScore > targetScore {
        return totalCount - pointer
    } else {
        let valueToSubtract = max(pointer - 1, 0)
        return totalCount - valueToSubtract
    }
}

func createRealTargetIndex(startAt: Int, targetScore: Int, infos: [[String]]) -> Int {
    var currentIndex = startAt
    
    while currentIndex > 0 {
        if Int(infos[currentIndex-1][4])! == targetScore {
            currentIndex -= 1
        } else {
            break
        }
    }
    return currentIndex
}

func allQueriedInfo(from allInfos: [[String]], allConditions: [[String]]) -> [String: [[String]]] {
    let allQuery = allConditions.map { $0 + ["-"] }
    var queriedInfo = [String: [[String]]]()
    
    func createQueriedInfo(queryLevel: Int, queryString: String, filteredInfo: [[String]]) {
        if queryLevel < allQuery.count {
            let currentQuery = allQuery[queryLevel]
            
            currentQuery.forEach { condition in
                let newFilteredInfo = filteredInfo.filter { isSame($0[queryLevel], condition) }
                let newQueryString = queryString + condition
                createQueriedInfo(queryLevel: queryLevel + 1, queryString: newQueryString, filteredInfo: newFilteredInfo)
            }
        } else {
            queriedInfo[queryString] = filteredInfo
        }
    }
    createQueriedInfo(queryLevel: 0, queryString: "", filteredInfo: allInfos)
    return queriedInfo
}

func isSame(_ info: String, _ condition: String) -> Bool {
    if condition == "-" {
        return true
    } else {
        return info == condition
    }
}
```



#### 하 하얗게 불태웠다...

<img width="300" alt="스크린샷 2021-09-16 오후 5 21 34" src="https://user-images.githubusercontent.com/72188416/133577219-d37fd94b-5036-4133-a7da-a256f4f71d28.png">

